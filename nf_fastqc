#!/usr/bin/env nextflow
nextflow.enable.dsl=2

params.outdir = "."
params.fastqc_args = ''
params.verbose = false
params.single_end = false  // default mode is auto-detect. NOTE: params are handed over automatically 

if (params.verbose){
    println ("[WORKFLOW] FASTQC ARGS: "           + params.fastqc_args)
}

// Example command
// nf_fastqc --fastqc_args="--nogroup --adapter ~/adapter_list_with_contamination_one_off.txt" *fastq.gz

include { makeFilesChannel; getFileBaseNames } from './nf_modules/files.mod.nf'
include { FASTQC }                             from './nf_modules/fastqc.mod.nf'

file_ch = makeFilesChannel(args) 

workflow {

    main:
        FASTQC(file_ch, params.outdir, params.fastqc_args, params.verbose)
       
}

// // Since workflows with very long command lines tend to fail to get rendered at all, I was experimenting with a
// // minimal execution summary report so we at least know what the working directory was...
// workflow.onComplete {

//     def msg = """\
//         Pipeline execution summary
//         ---------------------------
//         Completed at: ${workflow.complete}
//         Duration    : ${workflow.duration}
//         Success     : ${workflow.success}
//         workDir     : ${workflow.workDir}
//         exit status : ${workflow.exitStatus}
//         """
//     .stripIndent()

//     sendMail(to: "${workflow.userName}@babraham.ac.uk", subject: 'Minimal pipeline execution report', body: msg)
// }